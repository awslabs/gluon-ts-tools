import itertools
import math
import re
from functools import partial, singledispatch
from uuid import uuid4

from runtool.datatypes import Versions
from runtool.runtool import DotDict
from runtool.utils import update_nested_dict

from typing import Callable, Any, Union
from runtool.utils import get_item_from_path


@singledispatch
def recursive_apply(node, fn: Callable) -> Any:
    """
    Applies a function to dict nodes in a JSON-like structure.
    The node that the function is applied to will be replaced with what `fn` returns.

    Simple example:

        node = {"this": "is removed", "double": 1}
        fn = lambda dct: 2 * dct["double"] if "double" in dct else dct

    recursive_apply will return the value 2

    Another example:

        node = {
            "this": "stays",
            "double_this": {
                "this": "is removed",
                "double": 2
            },
        }
        fn = lambda node: 2 * node["double"] if "double" in node else node

    recursive_apply will here return: {'this': 'stays', 'double_this': 4}

    If the `fn` generates `runtool.datatypes.Versions` objects these `Versions`
    object are merged and returned.
    This happens for example when `fn` is `runtool.config_parser.do_each`
    see example below:

        node = {
            "my_list": [
                {"hello": "there"},
                {"a": {"$each": [1, 2]}},
                {"b": {"$each": [3, 4]}},
            ]
        }
        fn = runtool.config_parser.do_each

    recursive_apply will then return:

        Versions([
            {
                "my_list": [
                    {"hello": "there"},
                    {"a": 1},
                    {"b": 3},
                ]
            },
            {
                "my_list": [
                    {"hello": "there"},
                    {"a": 2},
                    {"b": 3},
                ]
            },
            {
                "my_list": [
                    {"hello": "there"},
                    {"a": 1},
                    {"b": 4},
                ]
            },
            {
                "my_list": [
                    {"hello": "there"},
                    {"a": 2},
                    {"b": 4},
                ]
            }
        ])
    """
    return node


@recursive_apply.register
def recursive_apply_dict(node: dict, fn: Callable) -> Any:
    """
    Applies `fn` to each element in the dict, if `fn` changes the node,
    the changes should be returned. If the `fn` foes not change the node,
    we recurse the children of the node.

    In case the recursion on the children results in Versions objects,
    we need to merge these and return a new Versions object.
    If no children are Versions objects, we return the children.

    Example handling a simple $eval statement:

        node={$eval: 2 + 2}
        fn=runtool.config_parser.do_eval

    children will be:
        4

    this function returns:
        4

    Example handling Versions objects as generated by $each:
        node={'a': {'$each':[1,2]}, 'b':{'$each':[3,4]}}
        fn=runtool.config_parser.do_each

    children of the `node` will after recursive_apply has been applied to them be:

        {
            'a': Versions([1,2]),
            'b': Versions([3.4])
        }

    this function returns:

        Versions([
            {'a': 1,'b':3},
            {'a': 2,'b':3},
            {'a': 1,'b':4},
            {'a': 2,'b':4}
        ])

    """
    # basecase of recursion, if `fn` modifies the node, return the new node
    new_node = fn(node)
    if new_node is not node:
        return new_node

    # else merge children of type Versions into a new Versions object
    expanded_children = []
    children = {}
    for key in node:
        child = recursive_apply(node[key], fn)
        if type(child) is Versions:
            expanded_children.append(itertools.product([key], child.versions))
        else:
            children[key] = child
    as_dicts = [dict(ver) for ver in itertools.product(*expanded_children)]

    if as_dicts == [{}]:
        return children

    for dct in as_dicts:
        dct.update(children)
    return Versions(versions=as_dicts)


@recursive_apply.register
def recursive_apply_list(node: list, fn: Callable) -> Any:
    """
    Continues the recursion on each element in the node, without applying the `fn`.
    Merges any Versions objects present in the children.

    Given:

    node = [1, Versions([2, 3]), 4, Versions([5, 6])]
    fn = lambda x: x

    this returns:
    Versions([[1,2,4,5], [1,2,4,6], [1,3,4,5], [1,3,4,6]])
    """
    versions_in_children = []
    child_normal = [None] * len(node)  # maintans indexes
    for index in range(len(node)):
        child = recursive_apply(node[index], fn)
        if isinstance(child, Versions):
            # child = Versions([1,2])
            # =>
            # expanded_child_version = ((index, 1), (index, 2))
            expanded_child_version = itertools.product([index], child.versions)
            versions_in_children.append(expanded_child_version)
        else:
            child_normal[index] = child

    if not versions_in_children:
        return child_normal

    # merge the data from the children which were not Versions objects
    # together with the data from the children which were Versions objects
    new_versions = []
    for version in itertools.product(*versions_in_children):
        new_data = child_normal[:]
        for index, value in version:
            new_data[index] = value
        new_versions.append(new_data)

    return Versions(versions=new_versions)


def apply_from(node: dict, data: dict) -> dict:
    """
    Update the node with the data which the path in node['$from'] is pointing to.
    i.e.
    data = {'another_node': {'a_key': {'hello': 'world'}}}
    node = {'$from': another_node.a_key, 'some_key':'some_value'}

    becomes:
    {'hello': 'world', 'some_key':'some_value'}
    """
    node = dict(**node)  # needed if $from reference another $from
    path = node.pop("$from")
    from_value = get_item_from_path(data, path)
    from_value = recursive_apply(from_value, partial(do_from, context=data))

    assert isinstance(
        from_value, dict
    ), "$from can only be used to inherit from a dict"
    from_value = update_nested_dict(from_value, node)
    return dict(**from_value)


def apply_ref(node, context):
    assert len(node) == 1, "$ref needs to be the only value"
    data = get_item_from_path(context, node["$ref"])
    return recursive_apply(data, partial(do_ref, context=context))


def evaluate(text, locals):
    uid = str(uuid4()).split("-")[-1]
    locals = {**DotDict(locals)}
    globals = {**math.__dict__, "uid": uid}
    ret = eval(
        text,
        globals,
        locals,
    )
    if isinstance(ret, dict) and "$eval" in ret:
        return do_eval(ret, locals)
    return ret


def recurse_trial(path, data):
    tmp = data
    current_path = []
    path = path.replace("[", ".").replace("]", "").replace('"', "")
    for key in path.split("."):
        try:
            tmp = tmp[key]
            current_path.append(key)
        except:
            break

    return ".".join(current_path), do_trial(tmp, data)


def apply_trial(node, locals):
    assert len(node) == 1, "$eval needs to be only value"
    text = str(node["$eval"])

    # dict used to remove duplicates
    matches = {
        text[item.start() : item.end()]: None
        for item in re.finditer(
            r"(__trial__(?:(?:\[[0-9]+\])|(?:\[(?:\'|\")[a-zA-Z_0-9$]+(?:\'|\")\])|(?:\.[a-zA-Z_0-9]+))+)",
            text,
        )
    }

    # find longest working path for each match in locals
    for path in matches:
        substring, value = recurse_trial(path, locals)

        if isinstance(value, dict) and "$eval" in value:
            raise TypeError("$eval: $trial cannot resolve to value")
        elif type(value) is str:
            text = text.replace(substring, f"'{value}'")
        else:
            text = text.replace(substring, str(value))

    return evaluate(text, locals)


def recurse_eval(path, data):
    # since values such as a.b.split() is allowed.
    # we need to identify what are values in the dict
    # thus here we fetch as much info from the dict as possible
    # stopping whenever an unknown key is found
    tmp = data
    current_path = ["$"]
    path = path.replace("[", ".[")
    for key in path.split("."):
        try:
            original_key = key
            if "[" in key:
                key = key.replace("[", "").replace("]", "").replace('"', "")
            tmp = tmp[key]
            current_path.append(original_key)
        except:
            break
    return ".".join(current_path).replace(".[", "["), do_eval(tmp, data)


def apply_eval(node, locals):
    assert len(node) == 1, "$eval needs to be only value"
    text = str(node["$eval"])
    text = text.replace("$trial", "__trial__")

    # find all matches of $.somestring.somotherstring[0]['dsd']["sdasda"] ...
    matches = {
        text[item.start() : item.end()]: text[item.start() + 2 : item.end()]
        for item in re.finditer(
            r"(\$(?:(?:\[[0-9]+\])|(?:\[(?:\'|\")[a-zA-Z_0-9$]+(?:\'|\")\])|(?:\.[a-zA-Z_0-9]+))+)",
            text,
        )
    }

    for path in matches.values():
        current_path, value = recurse_eval(path, locals)
        if isinstance(value, dict) and "$eval" in value:
            text = text.replace(current_path, f"({value['$eval']})")
        elif type(value) is str:
            text = text.replace(current_path, f"'{value}'")
        else:
            text = text.replace(current_path, str(value))

    try:
        return evaluate(text, locals)
    except NameError as error:
        if "__trial__" in str(error):
            node["$eval"] = text
            return node
        else:
            raise error


def apply_each(node, context):
    # should return th different versions
    # item.e. $each: [1,2] should return two versions in an array

    each = recursive_apply(
        node.pop("$each"), partial(do_each, context=context)
    )
    if isinstance(each, list):
        # check if all are dicts or has the $None tag
        if all(
            map(lambda item: isinstance(item, dict) or item == "$None", each)
        ):
            new = []
            for item in each:
                if item == "$None":
                    new.append(node)
                else:
                    item.update(node)
                    new.append(item)
            each = new
        else:
            each = [item if not item == "$None" else None for item in each]
        return Versions(versions=each)
    elif isinstance(each, dict):
        seperated_dicts = [{key, val} for key, val in each.items()]
        for a_dict in seperated_dicts:
            a_dict.update(node)
        return Versions(versions=seperated_dicts)
    elif isinstance(each, Versions):
        # when having a nested $each this will be triggered
        flattened = itertools.chain.from_iterable(each.versions)
        return Versions(versions=list(flattened))
    else:
        print("Something went wrong when expanding $each")
        raise NotImplementedError


# DO: find correct place within the data to do the transformation
def do_from(node, context):
    if isinstance(node, dict) and "$from" in node:
        return apply_from(node, context)
    return node


def do_ref(node, context):
    if isinstance(node, dict) and "$ref" in node:
        return apply_ref(node, context)
    return node


def do_eval(node, locals):
    if isinstance(node, dict) and "$eval" in node:
        return apply_eval(node, locals)
    return node


def do_trial(node, locals):
    if isinstance(node, dict) and "$eval" in node:
        return apply_trial(node, locals)
    return node


def do_each(node, context):
    if isinstance(node, dict) and "$each" in node:
        return apply_each(node, context)
    return node


def to_list(data):
    if type(data) is Versions:
        return data.versions
    else:
        return [data]


def apply_transformations(data):
    data = recursive_apply(data, partial(do_from, context=data))
    data = recursive_apply(data, partial(do_eval, locals=data))
    data = recursive_apply(data, partial(do_each, context=data))
    data = [
        recursive_apply(item, partial(do_ref, context=item))
        for item in to_list(data)
    ]
    return data
